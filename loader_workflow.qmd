---
title: "Loader Table Workflow"
format: html
editor: visual
---

## Introduction

This quarto document describes processing and quality assurance steps used to convert CDFW data into the format needed for ingest into vegbank. Each loader table has a function in the family `[table]_loader` which is run on input data and generates output files at the desired location. Messages from the loader functions indicate potential issues with input datasets.

```{r, echo = FALSE}
library(dplyr)
library(stringr)
library(readr)
library(DT)
#googlesheets4::gs4_auth()
```

```{r, echo = FALSE, message = FALSE, warning = FALSE}
file_path <- "R"
r_scripts_source <- list.files(file_path, recursive = FALSE, full.names = TRUE, pattern = "\\.[Rr]$") %>% 
  grep("stratadefinitions", ., invert = TRUE, value = TRUE)
invisible(lapply(r_scripts_source, source))
```

```{r}
in_dir <- '/var/data/curation/vegbank/'
out_dir <- 'data/loader-tables'
```

## Projects

Project loader table data is extracted from `RAProjects` files.

The project start and stop dates are converted from date-time formats to date formats (dropping the time). Date values are checked to ensure they are reasonable.

```{r}
project_loader(in_dir, out_dir)
```

## Party and Contributor

The two loader tables for Party and Contributor are both extracted from `RAProjects` files.

The source data is normalized, moving from wide to long format so that each individual in `DataContact*{n}` columns is in their own row. Emails are checked to ensure they appear valid. Names are then split using whitespace into `given_name`, `middle_name`, and `sur_name`. Unique party codes are generated for each individual (`user_py_code`). Additionally, all unique individuals already in vegbank are retrieved, along with their project codes. Individuals in the source data are matched to existing vegbank parties, and if any are found the existing vegbank identifier is assigned to `vb_py_code`.

`role` (a vegbank code starting with `ar.`) is derived from the `DataContactRole{n}` columns, which are free text. These values are standardized and mapped to VegBank role codes using a lookup table. The full mapping used in this process is shown below for transparency and review. If no role is found in the source data, the code ar.46 is assigned. The contributor_type field is given a value of "Project" for all rows.

```{r, echo=FALSE, message=FALSE, warning=FALSE}
# This is the VegBank role code reference (same as in party_contributor_loader)
roles <- tribble(
  ~ar_code, ~role_name,
  "ar.16",  "Author",
  "ar.17",  "Contact",
  "ar.18",  "PI",
  "ar.19",  "Data Manager",
  "ar.34",  "Classifier",
  "ar.36",  "Plot author",
  "ar.38",  "Co-PI",
  "ar.39",  "Computer (automated)",
  "ar.40",  "Consultant",
  "ar.43",  "Field assistant",
  "ar.44",  "Guide",
  "ar.45",  "Land owner",
  "ar.46",  "Not specified",
  "ar.47",  "Not specified/Unknown",
  "ar.48",  "Passive observer",
  "ar.50",  "Plot contributor",
  "ar.51",  "Publication author",
  "ar.53",  "Research advisor",
  "ar.54",  "System manager",
  "ar.55",  "Taxonomist",
  "ar.56",  "Data aggregator"
)

role_lookup_path <- file.path(in_dir, "lookup-tables", "cdfw-roles-2026-02-02.csv")

role_lookup <- read_csv(role_lookup_path, show_col_types = FALSE) %>%
  rename(ContactRole = found, role_name = allowed) %>%
  mutate(
    ContactRole = str_to_lower(str_squish(ContactRole)),
    role_name   = str_squish(role_name)
  )

role_map_final <- role_lookup %>%
  left_join(roles, by = "role_name") %>%
  arrange(role_name, ContactRole) %>%
  select(ContactRole, role_name, ar_code)

datatable(
  role_map_final,
  rownames = FALSE,
  filter = "top",
  options = list(
    pageLength = 25,
    autoWidth = TRUE,
    scrollX = TRUE
))
```

```{r}
party_contributor_loader(in_dir, out_dir)
```

## Disturbance

Disturbance data is extracted from `RAImpacts.csv` files, as well as the `LImpacts.csv` lookup table, which provides descriptive labels for impact codes.

Intensity values are checked to ensure they conform to expected values (1, 2, or 3). Valid intensity codes are converted to descriptive labels: 1 becomes "Low", 2 becomes "Moderate", and 3 becomes "High". Any non-standard intensity values are left as `NA`. Unknown values in the `CodeImpact` field not present in the impacts lookup table are identified. Impact codes present in the `CodeImpact` field but missing from the impacts lookup table are identified. These values are converted to `NA` in the `disturbance_type` field.

Disturbance age and extent are not present in the CDFW data. They are set to `NA` for all rows in the loader table.

The lookup table maps specific impact types from CDFW data to standardized VegBank disturbance categories. Detailed impact descriptions (i.e., "Development", "ORV activity", "Grazing", etc.) are converted into broader, standardized categories (i.e., "Human, general", "Roads and vehicular traffic", etc.) The full mapping used in this process is shown below for transparency and review.

```{r, echo = FALSE}
roles <- tribble(
  ~`CDFW Impact Type`,                        ~vegbank_disturbance,
    "Development",                            "Human, general",
    "ORV activity",                           "Roads and vehicular traffic",
    "Agriculture",                            "Cultivation",
    "Grazing",                                "Grazing, domestic stock",
    "Competition from exotics",               "Other disturbances",
    "Logging",                                "Timber harvest, general",
    "Insufficient population/stand size",     "Other disturbances",
    "Altered flood/tidal regime",             "Hydrologic alteration",
    "Mining",                                 "Human, general",
    "Hybridization",                          "Other disturbances",
    "Groundwater pumping",                    "Hydrologic alteration",
    "Dam/inundation",                         "Hydrologic alteration",
    "Other",                                  "Other disturbances",
    "Surface water diversion",                "Hydrologic alteration",
    "Road/trail construction/maint.",         "Roads and vehicular traffic",
    "Biocides",                               "Herbicide or chemical",
    "Pollution",                              "Human, general",
    "Unknown",                                "unknown",
    "Vandalism/dumping/litter",               "Human, general",
    "Foot traffic/trampling",                 "Trampling and trails",
    "Improper burning regime",                "Fire suppression",
    "Over collecting/poaching",               "Human, general",
    "Erosion/runoff",                         "Erosion",
    "Altered thermal regime",                 "Other disturbances",
    "Landfill",                               "Human, general",
    "Degrading water quality",                "Hydrologic alteration",
    "Wood cutting",                           "Timber harvest, selective",
    "Military operations",                    "Human, general",
    "Recreational use (non ORV)",              "Trampling and trails",
    "Nest parasitism",                        "Natural, general",
    "Non-native predators",                   "Other disturbances",
    "Rip-rap, bank protection",               "Hydrologic alteration",
    "Channelization (human caused)",           "Hydrologic alteration",
    "Feral pigs",                             "Animal, general",
    "Burros",                                 "Animal, general",
    "Rills",                                  "Erosion",
    "Phytogenic mounding",                    "Erosion",
    "Sudden Oak Death (SODS)",                 "Plant disease",
    NA, "Unknown"
)

datatable(
  roles,
  rownames = FALSE,
  filter = "top",
  options = list(
    pageLength = 25,
    autoWidth = TRUE,
    scrollX = TRUE
))
```

## Plots

### Data Sources and Initial Merging

Plot data is extracted from multiple CSV files, including `RAPlots.csv`, `AltPlots.csv`, and `AltStrata.csv`. These files are all merged into a single table using `SurveyID` as the join key. Empty columns are removed.

Survey dates are converted to Date format, and validation checks ensure dates fall between 1900 and the present day.

### Coordinate Standardization and Location Assignment

GPS datum values are standardized. EPSG codes are assigned based on the combination of datum and UTM zone. UTM coordinates are converted to latitude/longitude using the appropriate coordinate reference system (CRS) for each plot.

State and county assignments are determined by spatially joining plot coordinates with US state and county boundaries from the TIGRIS package. Plots with missing location information trigger warning messages, and manual corrections are applied for specific known locations.

Here are the CRS Assignment Rules:

```{r, echo=FALSE}
crs_lookup <- tribble(
  ~author_datum, ~UTM_zone, ~epsg,
  "WGS84", 10, 32610,
  "WGS84", 11, 32611,
  "NAD83", 10, 26910,
  "NAD83", 11, 26911,
  "NAD27", 10, 26710,
  "NAD27", 11, 26711
)

datatable(
  crs_lookup,
  rownames = FALSE,
  options = list(pageLength = 10, autoWidth = TRUE, scrollX = TRUE)
)
```

### Elevation and Location Accuracy

Elevation values are converted to **meters** when marked as feet in the source data. GPS error measurements are similarly converted to meters.

### Plot Area and Shape

Plot area is normalized by removing unit indicators (assuming square meters), converting hectares to square meters, and calculating area from plot dimensions or view radius when direct area measurements are unavailable. A value of **`-1`** indicates plots with no defined boundaries.

Plot shapes (circle, square, rectangle) are inferred from available dimension data when not explicitly recorded.

### Slope and Aspect

Slope aspect values are standardized, with flat locations coded as **`-1`** and variable locations as **`-2`**. Slope gradient is calculated from actual measurements when available. Otherwise, it is derived from slope category ranges using midpoint calculations.

### Substrate Cover (Rock and Gravel)

Rock and gravel cover is computed by summing percent cover values from the `Boulders`, `Stones`, `Cobbles`, and `Gravels` fields after treating `999` as missing. Values above 100 trigger warning messages.

```{r, echo=FALSE}
rock_gravel_rules <- tribble(
  ~source_fields, ~missing_rule, ~derived_field, ~derivation,
  "Boulders, Stones, Cobbles, Gravels", "999 → NA", "percentRockGravel", "row sum of the four fields (na.rm=TRUE); warn if >100"
)

datatable(
  rock_gravel_rules,
  rownames = FALSE,
  options = list(pageLength = 10, autoWidth = TRUE, scrollX = TRUE)
)
```

### Vegetation Height Classes

Height class fields for conifer, hardwood, shrub, and herbaceous vegetation are converted to numeric values by taking midpoints of ranges (e.g., `2–5 m → 3.5`). Less-than ranges (e.g., `<0.5 m`) are converted using a midpoint assumption (half of the threshold value), and "Not recorded" / "Not present" are treated as missing. Values that cannot be parsed trigger warning messages.

This doesn't hardcode every possible value, it just shows representative examples of the transformation rules.

```{r, echo=FALSE}
height_examples <- tribble(
  ~example_input, ~rule, ~numeric_output,
  "2-5 m", "midpoint of range", 3.5,
  "0.5-1 m", "midpoint of range", 0.75,
  "<0.5 m", "less-than midpoint rule (half)", 0.25,
  ">50 m", "greater-than rule (keep value or placeholder)", NA_real_,
  "Not recorded", "missing token → NA", NA_real_,
  "Not present", "missing token → NA", NA_real_
)

datatable(
  height_examples,
  rownames = FALSE,
  options = list(pageLength = 10, autoWidth = TRUE, scrollX = TRUE)
)
```

### Tree Growth Form Assignment

Growth form assignments prioritize the dominant tree type (conifer vs. hardwood) based on cover values, with the secondary growth form assigned to the less dominant type.

### Topographic Position

Topographic position values from the MacroTopo field are mapped to VegBank's topo_position values using the lookup table below.

```{r, echo = FALSE}
lookup_plot_position <- tribble(
    ~MacroTopo,                          ~topo_position,
    "Bottom",                               "Basin floor",
    "Lower 1/3 of slope",                   "Lowslope",
    "Bottom to Lower 1/3 of slope",          "Lowslope",
    "Bottom to Mid 1/3 of slope",            "Lowslope",
    "Bottom to Upper 1/3 of slope",          "Midslope",
    "Entire slope",                          "Midslope",
    "Middle 1/3 of slope",                   "Midslope",
    "Middle to Upper 1/3 of slope",          "Midslope",
    "Lower to Middle 1/3 of slope",           "Midslope",
    "Lower to Upper 1/3 of slope",            "Midslope",
    "Upper 1/3 of slope",                    "High slope",
    "Upper 1/3 of slope to Ridgetop",         "High slope",
    "Middle 1/3 of slope to Ridgetop",        "High slope",
    "Lower 1/3 of slope to Ridgetop",         "Midslope",
    "Ridge top",                             "Interfluve",
    "upper",                                "High slope",
    "mid",                                  "Midslope",
    "Bench",                                "Step in slope",
    "Channel bed",                           "Channel bed",
    "Lowslope",                              "Lowslope",
    "6",                                    "Basin floor",
    "Not recorded",                          NA_character_,
    "<Null>",                               NA_character_,
    "Lower 1/3 of slope to Ridegetop",               "Midslope",
    "Other",                                        NA_character_,
    "Wash (channel bed)",                            "Channel bed",
    "Toeslope",                                     "Toeslope",
    "Terrace (former shoreline or floodplain)",     "Low level",
    "Ridge Top",                                    "Interfluve",
    "Dune/sandfield",                               "Low level",
    "Draw",                                         "Channel bed",
    "Pediment",                                     "Lowslope",
    "Unknown",                                      NA_character_,
    "Edge of basin/wetland",                        "Basin floor",
    "* choose one *",                               NA_character_,
    "Badland (complex of draws & interfluves)",     "Midslope",
    "High slope",                                   "High slope",
    "Midslope",                                     "Midslope",
    "Low level",                                    "Low level",
    "Step in slope",                                "Step in slope",
    "Toe-slope",                                    "Toeslope",
    "Saddle/Summit/Ridgeline",                      "Interfluve",
    "Mid-slope",                                    "Midslope",
    "Braided/flood plain",                          "Low level",
    "Rolling Hills/Ridges",                         "Interfluve",
    "Broad wash",                                   "Channel bed",
    "Bar/swale",                                    "Low level",
    "Bajada",                                       "Toeslope",
    "Pavements",                                    "High level",
    "Valley",                                       "Low level",
    "Playa",                                        "Basin floor",
    "Narrow wash",                                  "Channel bed",
    "Deeply dissected hills",                       "Midslope",
    "Mud hills/Badlands",                           "Midslope",
    "Entire Slope",                                 "Midslope",
    "Basin/Wetland",                                "Basin floor",
    "Eroded Hills",                                 "Midslope",
    "Flat",                                         "Low level",
    "Toeslope (alluvial fan/bajada)",               "Toeslope",
    "High level/summit to HighSlope",               "High slope",
    "Basin/wetland",                                "Basin floor",
    "Low- to midslope",                             "Midslope",
    "High level/summit",                            "High level",
    "Lower",                                        "Lowslope",
    "Mid",                                          "Midslope",
    "Upper",                                        "High slope",
    "Top",                                          "Interfluve",
    "High level",                                   "High level",
    "Basin floor",                                  "Basin floor",
    "Channel wall",                                 "Channel wall",
    "Interfluve/Summit",                            "Interfluve",
    "bottom",                                       "Low level"
  )

datatable(
  lookup_plot_position,
  rownames = FALSE,
  filter = "top",
  options = list(
    pageLength = 25,
    autoWidth = TRUE,
    scrollX = TRUE
))
```

### Loader Table Field Mapping

The table below shows how processed plot fields are mapped into the VegBank PlotObservations loader table.

```{r, echo=FALSE}
plot_lt_mapping <- tribble(
  ~loader_field, ~source_field,
  "user_ob_code", "SurveyID",
  "user_pl_code", "Stand_ID",
  "author_plot_code", "Stand_ID",
  "latitude", "real_latitude",
  "longitude", "real_longitude",
  "location_accuracy", "ErrorMeasurement",
  "confidentiality_status", "ConfidentialityStatus",
  "author_e", "UTME_final",
  "author_n", "UTMN_final",
  "author_zone", "UTM_zone",
  "author_datum", "author_datum",
  "author_location", "SiteLocation",
  "azimuth", "W_Axis_Bearing",
  "shape", "PlotShape",
  "area", "PlotArea",
  "stand_size", "Stand_Size",
  "elevation", "Elevation",
  "slope_aspect", "Aspect_actual",
  "slope_gradient", "slope",
  "topo_position", "topo_position",
  "rock_type", "Substrate",
  "user_pj_code", "ProjectCode",
  "obs_start_date", "SurveyDate",
  "method_narrative", "methodNarrative",
  "tree_ht", "treeHt",
  "shrub_ht", "Shrub_ht22",
  "field_ht", "Herb_ht22",
  "tree_cover", "treeCover",
  "shrub_cover", "Shrub_cover",
  "field_cover", "Herb_cover",
  "growthform_1_type", "growthform1Type",
  "growthform_2_type", "growthform2Type",
  "growthform_1_cover", "growthform1Cover",
  "growthform_2_cover", "growthform2Cover"
)

datatable(
  plot_lt_mapping,
  rownames = FALSE,
  filter = "top",
  options = list(pageLength = 25, autoWidth = TRUE, scrollX = TRUE)
)
```

## Soils

```{r}
soil_loader(in_dir, out_dir)
```

## Community

### Data Sources and Merging
Community classification data is extracted from `RAClassifications.csv` files, along with `RAPlots.csv` and `RAProjects.csv` files. These files are all merged into a single table using `ProjectCode` as the join key. Empty columns are removed.

Classification methods are standardized using a lookup table that maps project codes to classification techniques. Three classification approaches are identified from project metadata: inspection-based classification, multi-variate analysis, and table analysis. Classification descriptions and tools from project records are concatenated into a `class_notes` field, with empty or redundant entries cleaned. 

### Class Confidence
Confidence values from the `Confidence_ID` field are normalized to three categories: "High", "Medium" and "Low". The function handles multiple input formats including single letters (H, M, L), full words (High, Medium, Low), and percentage values. Percentages of 75% or greater are mapped to "High", while values below 75% are mapped to "Medium". Missing value indicators are converted to NA. Any unparseable or unexpected confidence values trigger warnings. 

### Community Concept Matching
Community concepts are downloaded from the VegBank API and cached locally. Only currently accepted concepts are used for matching. California vegetation codes (`CaCode`) from the CDFW data are matched to NVC (National Vegetation Classification) codes using a crosswalk table (`VegBank_CrosswalkHierarchyMCV.csv`). NVC codes are then matched to VegBank community concept codes (`cc_code`). 
For CaCodes that map to multiple NVC codes, only the first mapping is used to prevent row duplication, although a warning is issued. Records without successful matches (no corresponding VegBank community concept) are flagged and exported to a separate file (`cacode-nolookup.csv`) for review. The total count of unmatched records is reported via warning message.

The final loader table links each survey observation to its community classification, confidence level, classification methods used, and corresponding VegBank community concept code.

```{r}
community_loader(in_dir, out_dir)
```

## Strata, Cover, Taxonomy

```{r}
stratacover_taxon_loader(in_dir, out_dir)
```
