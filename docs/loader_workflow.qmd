---
title: "Loader Table Workflow"
format:
  html:
    output-dir: ./docs
    toc: true
    number-sections: true
    css: style.css
---

## Introduction

This quarto document describes processing and quality assurance steps used to convert CDFW data into the format needed for ingest into vegbank. Each loader table has a function in the family `[table]_loader` which is run on input data and generates output files at the desired location. Messages from the loader functions indicate potential issues with input datasets.

```{r, echo = FALSE, warning = FALSE, message = FALSE}
library(dplyr)
library(stringr)
library(readr)
library(DT)
library(downloadthis)
```

```{r, echo = FALSE, message = FALSE, warning = FALSE}
file_path <- "../R"
r_scripts_source <- list.files(file_path, recursive = FALSE, full.names = TRUE, pattern = "\\.[Rr]$") %>% 
  grep("altplots", ., invert = TRUE, value = TRUE)
invisible(lapply(r_scripts_source, source))
```

```{r}
in_dir <- '/var/data/curation/vegbank/'
out_dir <- '../data/loader-tables'
```

## Projects

```{r}
#| classes: styled-output
project_loader(in_dir, out_dir)
```

Project loader table data is extracted from `RAProjects` files.

The project start and stop dates are converted from date-time formats to date formats (dropping the time). Date values are checked to ensure they are reasonable.

## Party and Contributor

```{r}
#| classes: styled-output
party_contributor_loader(in_dir, out_dir)
```

The two loader tables for Party and Contributor are both extracted from `RAProjects` files.

The source data is normalized, moving from wide to long format so that each individual in `DataContact*{n}` columns is in their own row. Emails are checked to ensure they appear valid. Names are then split using whitespace into `given_name`, `middle_name`, and `sur_name`. Unique party codes are generated for each individual (`user_py_code`). Additionally, all unique individuals already in vegbank are retrieved, along with their project codes. Individuals in the source data are matched to existing vegbank parties, and if any are found the existing vegbank identifier is assigned to `vb_py_code`.

`role` (a vegbank code starting with `ar.`) is derived from the `DataContactRole{n}` columns, which are free text. These values are standardized and mapped to VegBank role codes using a lookup table. The full mapping used in this process is shown below for transparency and review. If no role is found in the source data, the code ar.46 is assigned. The `contributor_type` field is given a value of "Project" for all rows.

```{r, echo=FALSE, message=FALSE, warning=FALSE}
# This is the VegBank role code reference (same as in party_contributor_loader)
roles <- tribble(
  ~ar_code, ~role_name,
  "ar.16",  "Author",
  "ar.17",  "Contact",
  "ar.18",  "PI",
  "ar.19",  "Data Manager",
  "ar.34",  "Classifier",
  "ar.36",  "Plot author",
  "ar.38",  "Co-PI",
  "ar.39",  "Computer (automated)",
  "ar.40",  "Consultant",
  "ar.43",  "Field assistant",
  "ar.44",  "Guide",
  "ar.45",  "Land owner",
  "ar.46",  "Not specified",
  "ar.47",  "Not specified/Unknown",
  "ar.48",  "Passive observer",
  "ar.50",  "Plot contributor",
  "ar.51",  "Publication author",
  "ar.53",  "Research advisor",
  "ar.54",  "System manager",
  "ar.55",  "Taxonomist",
  "ar.56",  "Data aggregator"
)

role_lookup_path <- file.path(in_dir, "lookup-tables", "cdfw-roles-2026-02-02.csv")

role_lookup <- read_csv(role_lookup_path, show_col_types = FALSE) %>%
  rename(ContactRole = found, role_name = allowed) %>%
  mutate(
    ContactRole = str_to_lower(str_squish(ContactRole)),
    role_name   = str_squish(role_name)
  )

role_map_final <- role_lookup %>%
  left_join(roles, by = "role_name") %>%
  arrange(role_name, ContactRole) %>%
  select(ContactRole, role_name, ar_code)

datatable(
  role_map_final,
  rownames = FALSE,
  filter = "top",
  options = list(
    pageLength = 10
))

role_map_final %>% 
downloadthis::download_this(
  path = "cdfw_role_mappings.csv",
  output_name = "role_map",
  button_label = "Download Role Mappings as CSV",
  button_type = "primary",
  has_icon = TRUE,
  icon = "fa fa-download"
)
```

## Disturbance

```{r}
#| classes: styled-output
disturbance_loader(in_dir, out_dir)
```

### Data Sources and Merging

Disturbance data is extracted from `RAImpacts.csv` files, as well as the `LImpacts.csv` lookup table, which provides descriptive labels for impact codes.

Intensity values are checked to ensure they conform to expected values (1, 2, or 3). Valid intensity codes are converted to descriptive labels: 1 becomes "Low", 2 becomes "Moderate", and 3 becomes "High". Any non-standard intensity values are left as `NA`. Unknown values in the `CodeImpact` field not present in the impacts lookup table are identified. Impact codes present in the `CodeImpact` field but missing from the impacts lookup table are identified. These values are converted to `NA` in the `disturbance_type` field.

Disturbance age and extent are not present in the CDFW data. They are set to `NA` for all rows in the loader table.

The table below maps specific impact types from CDFW data to standardized VegBank disturbance categories.

```{r, echo = FALSE}
dist <- tribble(
  ~`CDFW Impact Type`,                        ~vegbank_disturbance,
    "Development",                            "Human, general",
    "ORV activity",                           "Roads and vehicular traffic",
    "Agriculture",                            "Cultivation",
    "Grazing",                                "Grazing, domestic stock",
    "Competition from exotics",               "Other disturbances",
    "Logging",                                "Timber harvest, general",
    "Insufficient population/stand size",     "Other disturbances",
    "Altered flood/tidal regime",             "Hydrologic alteration",
    "Mining",                                 "Human, general",
    "Hybridization",                          "Other disturbances",
    "Groundwater pumping",                    "Hydrologic alteration",
    "Dam/inundation",                         "Hydrologic alteration",
    "Other",                                  "Other disturbances",
    "Surface water diversion",                "Hydrologic alteration",
    "Road/trail construction/maint.",         "Roads and vehicular traffic",
    "Biocides",                               "Herbicide or chemical",
    "Pollution",                              "Human, general",
    "Unknown",                                "unknown",
    "Vandalism/dumping/litter",               "Human, general",
    "Foot traffic/trampling",                 "Trampling and trails",
    "Improper burning regime",                "Fire suppression",
    "Over collecting/poaching",               "Human, general",
    "Erosion/runoff",                         "Erosion",
    "Altered thermal regime",                 "Other disturbances",
    "Landfill",                               "Human, general",
    "Degrading water quality",                "Hydrologic alteration",
    "Wood cutting",                           "Timber harvest, selective",
    "Military operations",                    "Human, general",
    "Recreational use (non ORV)",              "Trampling and trails",
    "Nest parasitism",                        "Natural, general",
    "Non-native predators",                   "Other disturbances",
    "Rip-rap, bank protection",               "Hydrologic alteration",
    "Channelization (human caused)",           "Hydrologic alteration",
    "Feral pigs",                             "Animal, general",
    "Burros",                                 "Animal, general",
    "Rills",                                  "Erosion",
    "Phytogenic mounding",                    "Erosion",
    "Sudden Oak Death (SODS)",                 "Plant disease",
    NA, "Unknown"
)

datatable(
  dist,
  rownames = FALSE,
  filter = "top",
  options = list(
    pageLength = 25
))

dist %>% 
downloadthis::download_this(
  path = "cdfw_disturbance_mappings.csv",
  output_name = "disturbance_map",
  button_label = "Download Disturbance Mappings as CSV",
  button_type = "primary",
  has_icon = TRUE,
  icon = "fa fa-download"
)
```

## Plots

```{r}
#| classes: styled-output
plots_loader(in_dir, out_dir)
```

### Data Sources and Initial Merging

Plot data is extracted from multiple CSV files, including `RAPlots.csv`, `AltPlots.csv`, and `AltStrata.csv`. These files are all merged into a single table using `SurveyID` as the join key. Empty columns are removed.

Survey dates are converted to Date format, and validation checks ensure dates fall between 1900 and the present day.

### Coordinate Standardization and Location Assignment

GPS datum values are standardized. EPSG codes are assigned based on the combination of datum and UTM zone. UTM coordinates are converted to latitude/longitude using the appropriate coordinate reference system (CRS) for each plot.

Here are the CRS Assignment Rules:

```{r, echo=FALSE}
crs_lookup <- tribble(
  ~author_datum, ~UTM_zone, ~epsg,
  "WGS84", 10, 32610,
  "WGS84", 11, 32611,
  "NAD83", 10, 26910,
  "NAD83", 11, 26911,
  "NAD27", 10, 26710,
  "NAD27", 11, 26711
)

datatable(
  crs_lookup,
  rownames = FALSE,
  options = list(pageLength = 10,
                 columnDefs = list(list(className = 'dt-center',
                                        targets = '_all')))
)
```

### Elevation and Location Accuracy

Elevation values are converted to **meters** when marked as feet in the source data. GPS error measurements are similarly converted to meters.

### Plot Area and Shape

Plot area is normalized by removing unit indicators (assuming square meters), converting hectares to square meters, and calculating area from plot dimensions or view radius when direct area measurements are unavailable. A value of **`-1`** indicates plots with no defined boundaries.

Plot shapes (circle, square, rectangle) are inferred from available dimension data when not explicitly recorded.

### Slope and Aspect

Slope aspect values are standardized, with flat locations coded as **`-1`** and variable locations as **`-2`**. Slope gradient is calculated from actual measurements when available. Otherwise, it is derived from slope category ranges using midpoint calculations.

### Substrate Cover (Rock and Gravel)

Rock and gravel cover is computed by summing percent cover values from the `Boulders`, `Stones`, `Cobbles`, and `Gravels` fields after treating `999` as missing. Values above 100 trigger warning messages.

### Vegetation Height Classes

Height class fields for conifer, hardwood, shrub, and herbaceous vegetation are converted to numeric values by taking midpoints of ranges (e.g., `2–5 m - 3.5`). Less-than ranges (e.g., `<0.5 m`) are converted using a midpoint assumption (half of the threshold value), and "Not recorded" / "Not present" are treated as missing. Values that cannot be parsed trigger warning messages.

The table below shows representative examples of the transformation rules.

```{r, echo=FALSE}
height_examples <- tribble(
  ~example_input, ~rule, ~numeric_output,
  "2-5 m", "midpoint of range", 3.5,
  "0.5-1 m", "midpoint of range", 0.75,
  "<0.5 m", "midpoint of range assuming 0 as low end", 0.25,
  ">50 m", "higher than 50 m", 55,
  "Not recorded", "missing token → NA", NA_real_,
  "Not present", "missing token → NA", NA_real_
)

datatable(
  height_examples,
  rownames = FALSE,
  options = list(pageLength = 10, autoWidth = TRUE, scrollX = TRUE)
)
```

### Tree Growth Form Assignment

Growth form assignments prioritize the dominant tree type (conifer vs. hardwood) based on cover values, with the secondary growth form assigned to the less dominant type.

### Topographic Position

Topographic position values from the MacroTopo field are mapped to VegBank's topo_position values using the lookup table below.

```{r, echo = FALSE}
lookup_plot_position <- tribble(
    ~MacroTopo,                          ~topo_position,
    "Bottom",                               "Basin floor",
    "Lower 1/3 of slope",                   "Lowslope",
    "Bottom to Lower 1/3 of slope",          "Lowslope",
    "Bottom to Mid 1/3 of slope",            "Lowslope",
    "Bottom to Upper 1/3 of slope",          "Midslope",
    "Entire slope",                          "Midslope",
    "Middle 1/3 of slope",                   "Midslope",
    "Middle to Upper 1/3 of slope",          "Midslope",
    "Lower to Middle 1/3 of slope",           "Midslope",
    "Lower to Upper 1/3 of slope",            "Midslope",
    "Upper 1/3 of slope",                    "High slope",
    "Upper 1/3 of slope to Ridgetop",         "High slope",
    "Middle 1/3 of slope to Ridgetop",        "High slope",
    "Lower 1/3 of slope to Ridgetop",         "Midslope",
    "Ridge top",                             "Interfluve",
    "upper",                                "High slope",
    "mid",                                  "Midslope",
    "Bench",                                "Step in slope",
    "Channel bed",                           "Channel bed",
    "Lowslope",                              "Lowslope",
    "6",                                    "Basin floor",
    "Not recorded",                          NA_character_,
    "<Null>",                               NA_character_,
    "Lower 1/3 of slope to Ridegetop",               "Midslope",
    "Other",                                        NA_character_,
    "Wash (channel bed)",                            "Channel bed",
    "Toeslope",                                     "Toeslope",
    "Terrace (former shoreline or floodplain)",     "Low level",
    "Ridge Top",                                    "Interfluve",
    "Dune/sandfield",                               "Low level",
    "Draw",                                         "Channel bed",
    "Pediment",                                     "Lowslope",
    "Unknown",                                      NA_character_,
    "Edge of basin/wetland",                        "Basin floor",
    "* choose one *",                               NA_character_,
    "Badland (complex of draws & interfluves)",     "Midslope",
    "High slope",                                   "High slope",
    "Midslope",                                     "Midslope",
    "Low level",                                    "Low level",
    "Step in slope",                                "Step in slope",
    "Toe-slope",                                    "Toeslope",
    "Saddle/Summit/Ridgeline",                      "Interfluve",
    "Mid-slope",                                    "Midslope",
    "Braided/flood plain",                          "Low level",
    "Rolling Hills/Ridges",                         "Interfluve",
    "Broad wash",                                   "Channel bed",
    "Bar/swale",                                    "Low level",
    "Bajada",                                       "Toeslope",
    "Pavements",                                    "High level",
    "Valley",                                       "Low level",
    "Playa",                                        "Basin floor",
    "Narrow wash",                                  "Channel bed",
    "Deeply dissected hills",                       "Midslope",
    "Mud hills/Badlands",                           "Midslope",
    "Entire Slope",                                 "Midslope",
    "Basin/Wetland",                                "Basin floor",
    "Eroded Hills",                                 "Midslope",
    "Flat",                                         "Low level",
    "Toeslope (alluvial fan/bajada)",               "Toeslope",
    "High level/summit to HighSlope",               "High slope",
    "Basin/wetland",                                "Basin floor",
    "Low- to midslope",                             "Midslope",
    "High level/summit",                            "High level",
    "Lower",                                        "Lowslope",
    "Mid",                                          "Midslope",
    "Upper",                                        "High slope",
    "Top",                                          "Interfluve",
    "High level",                                   "High level",
    "Basin floor",                                  "Basin floor",
    "Channel wall",                                 "Channel wall",
    "Interfluve/Summit",                            "Interfluve",
    "bottom",                                       "Low level"
  )

datatable(
  lookup_plot_position,
  rownames = FALSE,
  filter = "top",
  options = list(
    pageLength = 25
))

lookup_plot_position %>% 
downloadthis::download_this(
  path = "cdfw_plot_position_mappings.csv",
  output_name = "plot_position_map",
  button_label = "Download Plot Position Mappings as CSV",
  button_type = "primary",
  has_icon = TRUE,
  icon = "fa fa-download")
```

### Duplicates

Some `StandID` values were duplicated. Since `StandID` gets mapped to `user_pl_id`, the primary key of the plots table, duplicates in this field are not allowed. To resolve this issue, a suffix of `_{n}` was added to the end of duplicated plot ids. The table below shows the duplicated rows.

```{r}
plot_dupes <- read.csv(file.path(out_dir, "plotsLT.csv")) %>% 
  filter(grepl("_[0-9]$", user_pl_code)) %>% 
  select(user_pl_code, latitude, longitude, user_pj_code, user_ob_code)

datatable(
  plot_dupes,
  rownames = FALSE,
  filter = "top",
  options = list(
    pageLength = 10
))

plot_dupes %>% 
downloadthis::download_this(
  path = "cdfw_duplicate_plots.csv",
  output_name = "duplicate_plots",
  button_label = "Download Duplicate Plots as CSV",
  button_type = "primary",
  has_icon = TRUE,
  icon = "fa fa-download")

```


## Community

```{r}
#| classes: styled-output
community_loader(in_dir, out_dir)
```

### Data Sources and Merging

Community classification data is extracted from `RAClassifications.csv` files, along with `RAPlots.csv` and `RAProjects.csv` files. These files are all merged into a single table using `ProjectCode` as the join key. Empty columns are removed.

### Standardized Classification Methods

Classification methods are standardized using a lookup table that maps project codes to classification techniques. Three classification approaches are identified from project metadata: inspection-based classification, multi-variate analysis, and table analysis. Classification descriptions and tools from project records are concatenated into a `class_notes` field, with empty or redundant entries cleaned.

```{r, echo = FALSE, warning = FALSE, message = FALSE}
method_lookup <- read.csv(paste0(in_dir, "/lookup-tables/classification-methods-20260202.csv")) %>% 
  rename(vegbank_method = technique)

DT::datatable(method_lookup,
              rownames = FALSE,
              filter = "top",
              options = list(
                pageLength = 25
              ))

method_lookup %>% 
downloadthis::download_this(
  path = "cdfw_method_lookup_mappings.csv",
  output_name = "method_lookup_map",
  button_label = "Download Method Lookup Mappings as CSV",
  button_type = "primary",
  has_icon = TRUE,
  icon = "fa fa-download")
```

### Class Confidence

Confidence values from the `Confidence_ID` field are normalized to three categories: "High", "Medium" and "Low". The function handles multiple input formats including single letters (H, M, L), full words (High, Medium, Low), and percentage values. Percentages of 75% or greater are mapped to "High", while values below 75% are mapped to "Medium". Missing value indicators are converted to NA. Any unparse-able or unexpected confidence values trigger warnings. The confidence identifiers and percentages are mapped below.

### Community Concept Matching

Community concepts are downloaded from the VegBank API and cached locally. Only currently accepted concepts are used for matching. California vegetation codes (`CaCode`) from the CDFW data are matched to NVC (National Vegetation Classification) codes using a crosswalk table (`VegBank_CrosswalkHierarchyMCV.csv`). NVC codes are then matched to VegBank community concept codes (`cc_code`). For CaCodes that map to multiple NVC codes, only the first mapping is used to prevent row duplication, although a warning is issued. The total count of unmatched records is reported via warning message. Attached below is the matching process workflow.

Duplicated CaCode from the `VegBank_CrosswalkHierarchyMCV.csv` file are shown below.

```{r, echo = FALSE, warning = FALSE, message = FALSE}

# Load Reference Table
refs <- load_reference_tables(in_dir)

# Extract cacode_map from Reference Table
cacode_map <- refs$cacode_map

# Find duplicate cacode
dup <- cacode_map %>% 
  count(CaCode_norm) %>% 
  filter(n > 1)

duplicate_mappings <- cacode_map %>% 
  filter(CaCode_norm %in% dup$CaCode_norm) %>% 
  select(CaCode, CaCode_norm, `2009/NVC_Code`, NVC_norm, ScientificName) %>% 
  arrange(CaCode_norm)

# Display CommunityNames Table
datatable(
  duplicate_mappings, 
  rownames = FALSE,
  filter = "top",
  options = list(
    pageLength = 25,
    autoWidth = TRUE,
    columnDefs = list(
      list(className = 'dt-left', targets = c(0, 4)),
      list(className = 'dt-center', targets = c(1, 2, 3))
    )
  )
)

duplicate_mappings %>% 
downloadthis::download_this(
  path = "cdfw_cacode_duplicate_mapings.csv",
  output_name = "cacaode_duplicates",
  button_label = "Download Duplicated CaCode Mappings as CSV",
  button_type = "primary",
  has_icon = TRUE,
  icon = "fa fa-download")
```

## Strata, Cover, Taxonomy

```{r}
#| classes: styled-output
stratacover_taxon_loader(in_dir, out_dir)
```

```{r}
#| classes: styled-output
stratadefinitions_loader(in_dir, out_dir)
```

### Data Sources and Merging

Plant species data and vegetration strata are extracted from `RAPlants.csv` files, while project-level stratum methodology descriptions are from `RAProjects.csv` files. Each unique combination of `SurveyID` and stratum layer (`Stratum`) creates a distinct stratum identifier (i.e., `ALCC001_Shrub`). The data is processed to create two interconnected loader tables: one for strata cover (species abundance by vegetation layer) and one for taxonomic interpretations (linking species names to standardized plant concepts).

### Person Assignment for Taxonomic Interpretations

Each plant observation requires attribution to a person who made the taxonomic identification. To assign a person, all people listed under the project are joined to an observation. Then, the person who seems most likely to have made the classification according to their listed role is assigned to the record, and other personnel are dropped. The system prioritizes contributor roles in the following order to determine the most appropriate person (along with the associated AR code):

```{r, echo = FALSE, warning = FALSE, message = FALSE}
taxonomic_identifiers <- tibble::tribble(
    ~ar_code, ~role_name,
    "ar.55", "Taxonomist",
    "ar.34", "Classifier",
    "ar.18", "PI",
    "ar.38", "Co-PI",
    "ar.16", "Author",
    "ar.51", "Publication author",
    "ar.36", "Plot author",
    "ar.53", "Research advisor",
    "ar.19", "Data Manager",
    "ar.50", "Plot contributor",
    "ar.40", "Consultant",
    "ar.17", "Contact",
    "ar.54", "System manager",
    "ar.56", "Data aggregator",
    "ar.39", "Computer (automated)",
    "ar.43", "Field assistant",
    "ar.44", "Guide",
    "ar.48", "Passive observer",
    "ar.45", "Land owner",
    "ar.46", "Not specified",
    "ar.47", "Not specified/Unknown"
  )

datatable(
  taxonomic_identifiers,
  rownames = FALSE,
  filter = "top",
  options = list(pageLength = 25, autoWidth = TRUE, scrollX = TRUE)
)
```

### Plant Concept Matching

All plant concepts are downloaded from the VegBank API and cached locally. The matching process prioritizes USDA Plants reference lists, with preference given to the most recent version when a plant code appears in multiple lists.

If `CurrPlantsSymbol` (current USDA Plants symbol) is available, it is used to match to the USDA codes in vegbank. If not available, `CodeSpecies` is used. Similarly, `SpeciesName` takes precedence over `Species_name` for scientific names.

Normalized USDA plant codes are matched to VegBank plant concept codes (`pc_code`) through the plant concept database. Records without successful matches (missing `pc_code`) are flagged via warning messages, as plant concept codes are required for VegBank ingest.

### Strata Identification and Standardization

Each plant observation is assigned a unique stratum identifier by concatenating the survey ID (`SurveyID`) and stratum layer (`Stratum`). This links individual plant records to their vertical position in the vegetation structure (tree layer, shrub layer, herb layer, etc.)

Stratum names are normalized to lowercase and corrected based on project-specific rules to ensure consistency with VegBank stratum methods. The following lookup table is applied to determine which of the available vegbank methods best fits the project.

```{r}
method_lookup <- read.csv(file.path(in_dir, "lookup-tables/CDFW-strata-method.csv")) %>% 
  select(proj_code, stratum_method_name, Notes)

datatable(
  method_lookup,
  rownames = FALSE,
  filter = "top",
  options = list(pageLength = 25)
)
```

Based on the above, minor corrections were made to the projects and strata below.

```{r, echo = FALSE, warning = FALSE, message = FALSE}
strata_standardization <- tribble(
  ~`Project Code`, ~`Original Stratum`, ~`Corrected Stratum`,
  "ALCC", "nv", "non-vasc",
  "ALCC-GR", "nv", "non-vasc",
  "SCRUZ", "shrubs", "shrub",
  "SLAV", "shrubs", "shrub",
  "SLAV", "shrutb", "shrub",
  "SLAV", "shsrub", "shrub"
)

datatable(
  strata_standardization,
  rownames = FALSE,
  filter = "top",
  options = list(pageLength = 25, autoWidth = TRUE, scrollX = TRUE)
)
```

Three loader tables are generated:

1.  **Strata Cover Data** (`strataCoverLT.csv`) contains species abundance information, including the plant name as recorded by the author and the cover percentage.
2.  **Strata Definitions Data** (`strataDefinitionsLT.csv`) links to the survey observation and stratum definition.
3.  **Taxon Interpretations** (`taxonInterpretationsLT.csv`) links author-recorded plant names to standardized VegBank plant concept codes, includes attribution to the person who made the identification, and marks both `original_interpretation` and `current_interpretation` as TRUE since these represent the initial taxonomic determinations.

## New Community Concepts

Documentation will be written...

```{r}
#| classes: styled-output
community_definitions_loader(in_dir, out_dir)
```
